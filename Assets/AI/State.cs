// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System;

// Enum which specifies how positively or negatively close an enemy is to the player
public enum XCloseness {
	Small,
	Medium,
	Far,
	WallBetween
}

public enum YCloseness {
	PosSmall,
	PosMedium,
	PosFar,
	NegSmall,
	NegMedium,
	NegFar,
	WallBetween
}

// Class which takes in a world and creates a simplified state
public class State {

	// Players Weapon Type
	public WeaponType Weapon { get; set; }

	// Players Ammo
	public int	AmmoAmount { get; set; }

	// Enemy Weapon Type
	public WeaponType EnemyWeapon { get; set; }

	// Enemy Ammo
	public int EnemyAmmoAmount { get; set; }

	// XCloseness to Enemy
	public XCloseness XDistanceToEnemy { get; set; }

	// YCloseness to Enemy
	public YCloseness YDistanceToEnemy { get; set; }
	
	// Initialization method that simplifies a world into a state
	public State (World world, int playerNum) {

		World.Player player;
		World.Player enemy;

		// Set the player and enemy
		if (playerNum == 1) {
			player = world.Player1;
			enemy = world.Player2;
		}
		else {
			player = world.Player2;
			enemy = world.Player1;
		}

		// Set the player and enemy weapons and ammo amounts
		Weapon = player.Weapon;
		AmmoAmount = player.Ammo;
		EnemyWeapon = enemy.Weapon;
		EnemyAmmoAmount = enemy.Ammo;

		// Convert these distances into closeness types
		XDistanceToEnemy = HowXClose (world,playerNum);
		YDistanceToEnemy = HowYClose (world,playerNum);

		// Set the player and enemy health
		health = player.Health;
		enemyHealth = enemy.Health;
	}

	public State () {

		Weapon = WeaponType.None;
		AmmoAmount = 0;
		EnemyWeapon = WeaponType.None;
		EnemyAmmoAmount = 0;
		XDistanceToEnemy = XCloseness.WallBetween;
		YDistanceToEnemy = YCloseness.WallBetween;
	}

	// Returns all possible states
	static public List<State> AllPossible () {

		// Create empty list
		List<State> stateList = new List<State>();

		// Iterate through each property
		WeaponType[] weaponArray = new WeaponType[] {
			WeaponType.None,
			WeaponType.Bombs,
			WeaponType.Rockets,
			WeaponType.Minions,
			WeaponType.Lightning
		};

		int[] ammoArray = new int[]{-1,0,1,2,3};

		XCloseness[] xClosenessArray = new XCloseness[] { 
			XCloseness.Small,
			XCloseness.Medium,
			XCloseness.Far,
			XCloseness.WallBetween
		};

		YCloseness[] yClosenessArray = new YCloseness[] { 
			YCloseness.PosSmall,
			YCloseness.PosMedium,
			YCloseness.PosFar,
			YCloseness.NegSmall,
			YCloseness.NegMedium,
			YCloseness.NegFar,
			YCloseness.WallBetween
		};

		// weapon
		foreach (WeaponType tempWeapon in weaponArray) {

			// ammoAmount
			foreach (int tempAmmoAmount in ammoArray) {

				// enemyWeapon
				foreach (WeaponType tempEnemyWeapon in weaponArray) {

					// enemyAmmoAmount
					foreach (int tempEnemyAmmoAmount in ammoArray) {

						// xDistanceToEnemy
						foreach (XCloseness tempXDistanceToEnemy in xClosenessArray) {

							// yDistanceToEnemy
							foreach (YCloseness tempYDistanceToEnemy in yClosenessArray) {

								// create new state class with the above properties
								State newState = new State ();
								newState.Weapon = tempWeapon;
								newState.AmmoAmount = tempAmmoAmount;
								newState.EnemyWeapon = tempEnemyWeapon;
								newState.EnemyAmmoAmount = tempEnemyAmmoAmount;
								newState.XDistanceToEnemy = tempXDistanceToEnemy;
								newState.YDistanceToEnemy = tempYDistanceToEnemy;

								// add newState to stateList
								stateList.Add(newState);
							}
						}
					}
				}
			}
		}

		return stateList;
	}

	// Helper method which takes in a world and playerNum and returns the XCloseness of the player and the enemy
	public XCloseness HowXClose (World world, int playerNum) {

		World.Player player;
		World.Player enemy;

		// Set the player and enemy
		if (playerNum == 1) {
			player = world.Player1;
			enemy = world.Player2;
		} else {
			player = world.Player2;
			enemy = world.Player1;
		}

		// Calculate the x distance to the enemy
		float xDist = enemy.X - player.X;
		
		if (IsGroundBetween (world,"y",playerNum)) {
			return XCloseness.WallBetween;
		} else {

			if (0 <= xDist && xDist <= 2) {
				return XCloseness.Small;
			} else if (2 < xDist && xDist <= 8) {
				return XCloseness.Medium;
			} else {
				return XCloseness.Far;
			}
		}
	}
	
	// Method which takes in a world and playerNum and returns the XCloseness of the player and the enemy
	public YCloseness HowYClose (World world, int playerNum) {

		World.Player player;
		World.Player enemy;
		
		// Set the player and enemy
		if (playerNum == 1) {
			player = world.Player1;
			enemy = world.Player2;
		} else {
			player = world.Player2;
			enemy = world.Player1;
		}

		float yDist = enemy.Y - player.Y;

		if (IsGroundBetween (world,"y",playerNum)) {
			return YCloseness.WallBetween;
		} else {

			// If its a positive distance
			if (yDist >= 0) {
				if (0 <= yDist && yDist <= 2) {
					return YCloseness.PosSmall;
				} else if (2 < yDist && yDist <= 8) {
					return YCloseness.PosMedium;
				} else {
					return YCloseness.PosFar;
				}
			} else {
				if (0 <= yDist && yDist <= 2) {
					return YCloseness.NegSmall;
				} else if (2 < yDist && yDist <= 8) {
					return YCloseness.NegMedium;
				} else {
					return YCloseness.NegFar;
				}
			}
		}
	}

	public override string ToString () {

		string stateString = "";

		// Players Weapon Type
		stateString = stateString + Weapon.ToString ();
		stateString = stateString + " ";
		
		// Players Ammo
		stateString = stateString + AmmoAmount.ToString ();
		stateString = stateString + " ";
		
		// Enemy Weapon Type
		stateString = stateString + EnemyWeapon.ToString ();
		stateString = stateString + " ";
		
		// Enemy Ammo
		stateString = stateString + EnemyAmmoAmount.ToString ();
		stateString = stateString + " ";

		// XCloseness to Enemy
		stateString = stateString + XDistanceToEnemy.ToString ();
		stateString = stateString + " ";
		
		// YCloseness to Enemy
		stateString = stateString + YDistanceToEnemy.ToString ();

		return stateString;
	}

	static public State FromString (string stateString) {

		State state = new State ();

		string[] propertyArray = stateString.Split (' ');

		for (int i = 0; i < propertyArray.Count(); i++) {
			if (i == 0) {
				state.Weapon = (WeaponType) Enum.Parse (typeof(WeaponType), propertyArray [i]);
			} else if (i == 1) {
				state.AmmoAmount = int.Parse (propertyArray [i]);
			} else if (i == 2) {
				state.EnemyWeapon = (WeaponType) Enum.Parse (typeof(WeaponType), propertyArray [i]);
			} else if (i == 3) {
				state.EnemyAmmoAmount = int.Parse (propertyArray [i]);
			} else if (i == 4) {
				state.XDistanceToEnemy = (XCloseness) Enum.Parse (typeof(XCloseness), propertyArray [i]);
			} else if (i == 5) {
				state.YDistanceToEnemy = (YCloseness) Enum.Parse (typeof(YCloseness), propertyArray [i]);
			}
		}

		return state;
	}

	// Returns a bool on whether or not input state is the same as this state
	public bool IsEquivalent (State comparisonState) {

		return comparisonState.AmmoAmount == this.AmmoAmount && comparisonState.EnemyAmmoAmount == this.EnemyAmmoAmount && comparisonState.EnemyWeapon == this.EnemyWeapon && comparisonState.Weapon == this.Weapon && comparisonState.XDistanceToEnemy == this.XDistanceToEnemy && comparisonState.YDistanceToEnemy == this.YDistanceToEnemy;
	}

	public static float Reward (State initState, StrategyType strategy, State resultState) {
		return 0.0f;
	}




	// Takes in a world and a direction and checks if there is a ground between the two players in that direction
	bool IsGroundBetween (World world, string direction, int player) {

		float[] pos1;
		float[] pos2;

		// Check the Player
		if (player == 1) {
			pos1 = new float[]{world.Player1.X,world.Player2.Y};
			pos2 = new float[]{world.Player2.X,world.Player2.Y};
		} else {
			pos2 = new float[]{world.Player1.X,world.Player2.Y};
			pos1 = new float[]{world.Player2.X,world.Player2.Y};
		}

		// Check the Direction
		if (direction == "x") {

			// Iterate through each x
			foreach (float x in Enumerable.Range((int)pos1[0],(int)pos2[0])) {
				
				if (world.CheckGround(x,pos1[1])) {
					return true;
				}
			}
			
		} else if (direction == "y") {

			// Iterate through each y
			foreach (float y in Enumerable.Range((int)pos1[1],(int)pos2[1])) {
				
				if (world.CheckGround(pos1[0],y)) {
					return true;
				}
			}
		}

		return false;
	}

	float health;
	float enemyHealth;
}